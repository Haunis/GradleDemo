/**
 * https://docs.gradle.org/current/javadoc/org/gradle/api/Project.html
 *
 * >>>>>>>>>>>>每一个build.gradle文件都会转换成一个Project对象<<<<<<<
 *
 * 在Gradle术语中，Project对象对应的是BuildScript。 Project包含若干Tasks。
 * 由于Project对应具体的工程，所以需要为Project加载所需要的插件，
 * 比如为Java工程加载Java插件。其实，一个Project包含多少Task往往是插件决定的。
 *
 * 在Project中，要：
 *  1.加载插件。
 *  2.不同插件有不同的行话，即不同的配置。我们要在Project中配置好，这样插件就知道从哪里读取源文件等
 *  3.设置属性。
 */


//******************************1.加载application插件**********************************
/**
 * apply函数原型:apply(Map<String,>)
 * Groovy支持 函数调用的时候通过  参数名1:参数值2，参数名2：参数值2 的方式来传递参数
 *
 * plugins {id 'com.android.application'} //gradle6.8原生的
 */
apply plugin: "com.android.application"
println "app/build --> ****load success****"

println "app/build -->gradle.hashCode:" + gradle.hashCode()//只有一个gradle对象
println "app/build -->gradle.ext.api: " + gradle.ext.api //settings.gradle initEnvironment中赋的值
println "app/build -->rootDis: " + rootProject.getRootDir().getAbsolutePath() //工程根目录GradleDemo


//******************************2.加载utils.gradle**********************************
//加载自定义插件;当一个Project apply一个gradle文件的时候，这个gradle文件会转换成一个Script对象。
println "app/build --> apply utils.gradle--------------------------------"
apply from: rootProject.getRootDir().getAbsolutePath() + "/utils.gradle"
println "app/build -->ext.utils_name:" + project.ext.utils_name //utils.gradle中定义;
println "app/build -->ext.get_v_name():" + ext.get_v_name() //utils.gradle中定义;可以不用project名
println "build/build -->date: " + project.ext.getFormatDate()
println "app/build -->ext.disableDebugBuild(): " + project.ext.disableDebugBuild()

//根目录build.gradle ext属性
println "app/build -->config_int_value:" + rootProject.ext.config_int_value
println "app/build -->config_str_value:" + rootProject.ext.config_str_value


//++++++++++++++++++++++++++++++ 3.使用hook ++++++++++++++++++++++++++++++++++
//在 流程2和流程3 之间加个hook; 1和2之间的hook可以在根目录build.gradle加
//build.gradle执行流程: 1.setting.gradle --> 2.每个工程下的build.gradle --> 3.执行这些task
gradle.taskGraph.whenReady {
    graph -> println "app/build --> taskGraph.whenReady: " + graph
}

//在流程3后面加个hook
gradle.buildFinished {
    buildResult ->
        println "app/build --> buildFinished1: " + buildResult
        println "app/build --> buildFinished2: " + buildResult
        println "app/build --> buildFinished3: " + buildResult
        println "app/build --> buildFinished3: " + buildResult
        println "app/build --> buildFinished3: " + buildResult

        //不能拷贝
//        Copy myCopy = task(myCopy, type: Copy)
//        myCopy.from 'build/outputs/apk/debug/'
//        myCopy.into 'apks'
//        myCopy.include('*.apk')
}


//-----------------------------4.使用task  -------------------------------------
//Task是和Project关联的，所以，我们要利用Project的task函数来创建一个Task
//task myTask  //<==myTask是新建Task的名字
//task myTask { configure closure }
//task myType << { task action } //<==注意，<<符号是doLast的缩写
//task myTask(type: SomeType)
//task myTask(type: SomeType) { configure closure }

task myTask1  //myTask是新建Task的名字
task myTask2 { println "app/build -->task2" } //返回myTask2之前,会先执行里面的action
task myTask3 {
    println "app/build -->task3 out" //在第二阶段Configration阶段执行,执行任意一个任务都可以执行到此处
    doFirst {
        //第三阶段Execution阶段执行; 必须gradle myTask3才能执行到此处
        println "app/build -->task3 in"
    }
}

//建了一个Task对象，同时把closure做为一个action加到这个Task的action队列中，
// 并且告诉它“最后才执行这个closure”（注意，<<符号是doLast的代表）。
//task myTask4<< { println "build.gradle -->myTask4" } //error <<符号是doLast的缩写
task myTask4() { println "app/build -->task4" } //ok

//执行 ./gradlew assemble或者 ./gradlew app:assemble会执行该task
//对于Android编译，我一般指定gradle assemble它默认编译debug和release两种输出。
// 所以，下面这个段代码表示：tasks代表一个Projects中的所有Task，是一个容器,getByName表示找到指定名称的任务。
//这里要找的assemble任务，然后通过doLast添加了一个Action。这个Action就是copy产出物到设置的目标目录中去
tasks.getByName("assemble") {
    it.doLast {
        println "app/build -->task getByName project_name:$project.name,  it=$it"
        project.ext.copyOutput(true) //project代指本build.gradle的意思,可以不指定

        //不能拷贝
//        Copy myCopy = task(myCopy, type: Copy)
//        myCopy.from 'build/outputs/apk/debug/'
//        myCopy.into 'apks'
//        myCopy.include('*.apk')
    }
}


//执行 ./gradle myCopy即可拷贝; 或者用下述makeapk闭包的形式
Copy copyTask = task(copyTask, type: Copy)
copyTask.from 'build/outputs/apk/debug/'
copyTask.into 'apks'
copyTask.include('*.apk')

// ./gradlew app:makeapk 或者gradle app:makeapk
//如果执行别的task如gradle build,gradle app:myTask3,makeapk里面的println,都会执行,但是copy不会执行
//要想执行copy,必须要执行./gradlew app:makeapk
task makeapk(type: Copy) {
    println "app/build -->task makeapk "

//    delete "apks/app-debug.apk" //不能用匹配符*
    //删除apks下所有apk
    FileTree tree = fileTree(dir: 'apks/')
    tree.each { File file ->
        if (file.toString().contains("apk")) {
            delete file
            println "app/build --> task makeapk,delete " + file
        }
    }
    //拷贝
    from('build/outputs/apk/debug/')
    into('apks/')
    include('*.apk') //include ,exclude参数来设置过滤
    def name = "app-" + rootProject.ext.app_version + ".apk"
    //重命名
    rename('app-debug.apk', name)

}
makeapk.dependsOn(build)//依赖build,所以先build再执行makeapk
//makeapk.dependsOn(assemble)//依赖build,所以先build再执行makeapk

//++++++++++++++++++++++++++++++5.++++++++++++++++++++++++++++++
project.afterEvaluate {
    println "app/build -->afterEvaluate"
//    disableDebugBuild()
}

android {
    compileSdkVersion 29 //调用compileSdkVersion函数,传入29
    buildToolsVersion "30.0.2"

    defaultConfig {
        applicationId "com.jiage.gradledemo"
        minSdkVersion 16
        targetSdkVersion 29
        versionCode 1
        versionName "1.0"

        testInstrumentationRunner "androidx.test.runner.AndroidJUnitRunner"
    }

    buildTypes {
        release {
            minifyEnabled false
            proguardFiles getDefaultProguardFile('proguard-android-optimize.txt'), 'proguard-rules.pro'
        }
    }
    compileOptions {
        sourceCompatibility JavaVersion.VERSION_1_8
        targetCompatibility JavaVersion.VERSION_1_8
    }
    repositories {
        flatDir {
            dirs "libs"
        }
    }
}

dependencies {
    implementation fileTree(dir: 'libs', include: ['*.jar', '*.aar']) //ok
//    implementation(name: 'hellolib-debug', ext: 'aar')

    implementation 'androidx.appcompat:appcompat:1.1.0'
    implementation 'com.google.android.material:material:1.1.0'
    implementation 'androidx.constraintlayout:constraintlayout:1.1.3'
    testImplementation 'junit:junit:4.+'
    androidTestImplementation 'androidx.test.ext:junit:1.1.2'
    androidTestImplementation 'androidx.test.espresso:espresso-core:3.3.0'
}
